---
title: "Convert from .csv to a Shapefile in R"
teaching: 20
exercises: 10
questions:
- "How can I import CSV files as shapefiles in R?"
objectives:
- "Be able to import .csv files containing x,y coordinate locations into `R`."
- "Know how to convert a .csv to a spatial object."
- "Understand how to project coordinate locations provided in a Geographic Coordinate System (Latitude, Longitude) to a projected coordinate system (UTM)."
- "Be able to plot raster and vector data in the same plot to create a map."
keypoints:
- "It is important to know the projection (if any) of your point data prior to converting to a spatial object."
---

```{r setup, echo=FALSE}
source("../bin/chunk-options.R")
source("../setup.R")
knitr_fig_path("10-")
```

```{r load-libraries, echo = FALSE, results='hide'}
library(raster)
library(rgdal)
library(ggplot2)
library(dplyr)
library(sf)
```

```{r load-data, echo = FALSE}
# Learners will have this data loaded from earlier episode
lines_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HARV_roads.shp")
aoi_boundary_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HarClip_UTMZ18.shp")
```

> ## Things Youâ€™ll Need To Complete This Episode
> See the [lesson homepage]({{ site.baseurl }}) for detailed information about the software,
> data, and other prerequisites you will need to work through the examples in this episode.
{: .prereq}

This episode will review how to import spatial points stored in `.csv` (Comma Separated Value) format into `R` as an `sf` spatial object. We will also reproject data imported from a shapefile format, export this data as a shapefile as well as plot raster and vector data as layers in the same plot.

## Spatial Data in Text Format

The `HARV_PlotLocations.csv` file contains `x, y` (point) locations for study
plot where NEON collects data on
<a href="http://www.neonscience.org/science-design/collection-methods/terrestrial-organismal-sampling" target="_blank"> vegetation and other ecological metrics</a>.
We would like to:

* Create a map of these plot locations.
* Export the data in a `shapefile` format to share with our colleagues. This
shapefile can be imported into any GIS software.
* Create a map showing vegetation height with plot locations layered on top.

Spatial data are sometimes stored in a text file format (`.txt` or `.csv`). If
the text file has an associated `x` and `y` location column, then we can
convert it into an `sf` spatial object. The `sf` object allows us to store both the `x,y` values that represent the coordinate location
of each point and the associated attribute data - or columns describing each
feature in the spatial object.

We will use the `sf` and `raster` libraries in this episode.

## Import .csv
To begin let's import `.csv` file that contains plot coordinate `x, y`
locations at the NEON Harvard Forest Field Site (`HARV_PlotLocations.csv`) in
`R`.

```{r read-csv }
plot_locations_HARV <-
  read.csv("data/NEON-DS-Site-Layout-Files/HARV/HARV_PlotLocations.csv")

str(plot_locations_HARV)
```

We now have a dataframe that contains 21 locations (rows) and 16 variables (attributes). Note that all of our character data was imported into `R` as factor (categorical) data. Next, let's explore the dataframe to determine whether it contains columns with coordinate values. If we are lucky, our `.csv` will contain columns labeled:

 * "X" and "Y" OR
 * Latitude and Longitude OR
 * easting and northing (UTM coordinates)

Let's check out the column names of our dataframe. 

```{r find-coordinates }
names(plot_locations_HARV)
```

## Identify X,Y Location Columns

Our column names include several fields that might contain spatial information. The `plot_locations_HARV$easting`
and `plot_locations_HARV$northing` columns contain coordinate values. We can confirm
this by looking at the first six rows of our data.

```{r check-out-coordinates }
head(plot_locations_HARV$easting)
head(plot_locations_HARV$northing)
```

We have coordinate values in our dataframe. In order to convert our
dataframe to an `sf` object, we also need to know the CRS
associated with those coordinate values.

There are several ways to figure out the CRS of spatial data in text format.

1. We can check the file metadata in hopes that the CRS was recorded in the
data. 
2. We can explore the file itself to see if CRS information is embedded in the
file header or somewhere in the data columns.

Following the `easting` and `northing` columns, there is a `geodeticDa` and a
`utmZone` column. These appear to contain CRS information
(`datum` and `projection`). Let's view those next.

```{r view-CRS-info }
head(plot_locations_HARV$geodeticDa)
head(plot_locations_HARV$utmZone)
```

It is not typical to store CRS information in a column. But this particular
file contains CRS information this way. The `geodeticDa` and `utmZone` columns
contain the information that helps us determine the CRS:

* `geodeticDa`: WGS84  -- this is geodetic datum WGS84
* `utmZone`: 18

In
[When Vector Data Don't Line Up - Handling Spatial Projection & CRS in R]({{site.baseurl}}/09-vector-when-data-dont-line-up-crs/)
we learned about the components of a `proj4` string. We have everything we need
to assign a CRS to our data.frame.

To create the `proj4` associated with UTM Zone 18 WGS84 we can look up the
projection on the [Spatial Reference website](http://www.spatialreference.org/ref/epsg/wgs-84-utm-zone-18n/), which contains a list of CRS formats for each projection. From here, we can extract the [proj4 string for UTM Zone 18N WGS84](http://www.spatialreference.org/ref/epsg/wgs-84-utm-zone-18n/proj4/). 

However, if we have other data in the UTM Zone 18N projection, it's much
easier to use the `st_crs()` function to extract the CRS in `proj4` format from that object and 
assign it to our
new spatial object. We've seen this CRS before with our Harvard Forest roads data (`lines_HARV`).

```{r explore-units}
st_crs(lines_HARV)
```

The output above shows that the lines shapefile is in
UTM zone 18N. We can thus use the CRS from that spatial object to convert our
non-spatial dataframe into an `sf` object.

Next, let's create a `crs` object that we can use to define the CRS of our
`sf` object when we create it.

```{r crs-object }
utm18nCRS <- st_crs(lines_HARV)
utm18nCRS

class(utm18nCRS)
```

## .csv to sf object
Next, let's convert our dataframe into an `sf` object. To do
this, we need to specify:

1. The columns containing X (`easting`) and Y (`northing`) coordinate values
2. The CRS that the column coordinate represent (units are included in the CRS) - stored in our `utmCRS` object.

We will use the `st_as_sf()` function to perform the conversion.

```{r convert-csv-shapefile}
plot_locations_sp_HARV <- st_as_sf(plot_locations_HARV, coords = c("easting", "northing"), crs = utm18nCRS)
```

We should double check the CRS to make sure it is correct. 

```{r}
st_crs(plot_locations_sp_HARV)
```

## Plot Spatial Object
We now have a spatial `R` object, we can plot our newly created spatial object.

```{r plot-data-points}
plot(plot_locations_sp_HARV$geometry,
     main = "Map of Plot Locations")
```

## Define Plot Extent

In
[Open and Plot Shapefiles in R]({{site.baseurl}}/R/open-shapefiles-in-R/)
we learned about spatial object `extent`. When we plot several spatial layers in
`R`, the first layer that is plotted, becomes the extent of the plot. If we add
additional layers that are outside of that extent, then the data will not be
visible in our plot. It is thus useful to know how to set the spatial extent of
a plot using `xlim` and `ylim`.

To begin, let's plot our `aoiBoundary` object with our vegetation plots.

```{r plot-data}
# plot Boundary
plot(aoi_boundary_HARV$geometry,
     main = "AOI Boundary\nNEON Harvard Forest Field Site")

# add plot locations
plot(plot_locations_sp_HARV$geometry,
     pch = 8, add = TRUE)

# no plots added, why? CRS?
# view CRS of each
st_crs(aoi_boundary_HARV)
st_crs(plot_locations_sp_HARV)
```

When we attempt to plot the two layers together, the plot
locations are not rendered. Our data are in the same projection, so what is going on?

```{r compare-extents}
# view extent of each
st_bbox(aoi_boundary_HARV)
st_bbox(plot_locations_sp_HARV)

# add extra space to right of plot area;
# par(mar = c(5.1, 4.1, 4.1, 8.1), xpd=TRUE)
plot(st_convex_hull(st_sfc(st_union(plot_locations_sp_HARV))),
     col = "purple",
     xlab = "easting",
     ylab = "northing", lwd = 8,
     main = "Extent Boundary of Plot Locations \nCompared to the AOI Spatial Object",
     ylim = c(4712400, 4714000)) # extent the y axis to make room for the legend

plot(aoi_boundary_HARV$geometry,
     add = TRUE,
     lwd = 6,
     col = "springgreen")

legend("bottomright",
       #inset = c(-0.5,0),
       legend = c("Layer One Extent", "Layer Two Extent"),
       bty = "n",
       col = c("purple", "springgreen"),
       cex = .8,
       lty = c(1, 1),
       lwd = 6)
```

The **extents** of our two objects are **different**. `plot_locations_sp_HARV` is
much larger than `aoi_boundary_HARV`. When we plot `aoi_boundary_HARV` first, `R`
uses the extent of that object to as the plot extent. Thus the points in the
`plot_locations_sp_HARV` object are not rendered. To fix this, we can manually
assign the plot extent using `xlims` and `ylims`. We can grab the extent
values from the spatial object that has a larger extent. Let's try it.

<figure>
    <a href="{{ site.baseurl }}/images/dc-spatial-vector/spatial_extent.png">
    <img src="{{ site.baseurl }}/images/dc-spatial-vector/spatial_extent.png"></a>
    <figcaption>The spatial extent of a shapefile or R spatial object
    represents the geographic <b> edge </b> or location that is the furthest
    north, south, east and west. Thus is represents the overall geographic
    coverage of the spatial object. Source: National Ecological Observatory
    Network (NEON)
    </figcaption>
</figure>

```{r set-plot-extent}

plotLoc.extent <- st_bbox(plot_locations_sp_HARV)
plotLoc.extent
# grab the x and y min and max values from the spatial plot locations layer
xmin <- plotLoc.extent[1]
xmax <- plotLoc.extent[3]
ymin <- plotLoc.extent[2]
ymax <- plotLoc.extent[4]

# adjust the plot extent using x and ylim
plot(aoi_boundary_HARV$geometry,
     main = "NEON Harvard Forest Field Site\nModified Extent",
     border = "darkgreen",
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax))

plot(plot_locations_sp_HARV$geometry,
		 col = "purple",
		 add = TRUE)

# add a legend
legend("bottomright",
       legend = c("Plots", "AOI Boundary"),
       pch = c(8, NA),
       lty = c(NA, 1),
       bty = "n",
       col = c("purple", "darkgreen"),
       cex = .8)

```

> ## Challenge - Import & Plot Additional Points
> 
> We want to add two phenology plots to our existing map of vegetation plot
> locations.
> 
> Import the .csv: `HARV/HARV_2NewPhenPlots.csv` into `R` and do the following:
> 
> 1. Find the X and Y coordinate locations. Which value is X and which value is Y?
> 2. These data were collected in a geographic coordinate system (WGS84). Convert
> the dataframe into an `sf` object.
> 3. Plot the new points with the plot location points from above. Be sure to add
> a legend. Use a different symbol for the 2 new points!  You may need to adjust
> the X and Y limits of your plot to ensure that both points are rendered by `R`!
> 
> If you have extra time, feel free to add roads and other layers to your map!
> 
> HINT: Refer to
> [When Vector Data Don't Line Up - Handling Spatial Projection & CRS in R]({{site.baseurl}}/R/vector-data-reproject-crs-R/)
> for more on working with geographic coordinate systems. You may want to "borrow"
> the projection from the objects used in that episode!
> 
> > ## Answers
> > 
> > ```{r challenge-code-phen-plots, echo=TRUE, results="hide", warning=FALSE }
> > ## 1
> > # Read the .csv file
> > newplot_locations_HARV <-
> >   read.csv("data/NEON-DS-Site-Layout-Files/HARV/HARV_2NewPhenPlots.csv",
> >            stringsAsFactors = FALSE)
> > 
> > # look at the data structure -> locations in lat/long
> > str(newplot_locations_HARV)
> > 
> > ## 2
> > ## Find/ establish a CRS for new points
> > # Import the US boundary which is in a geographic WGS84 coordinate system
> > country_boundary_US <- st_read("data/NEON-DS-Site-Layout-Files/US-Boundary-Layers/US-Boundary-Dissolved-States.shp")
> > 
> > # grab the geographic CRS
> > geogCRS <- st_crs(country_boundary_US)
> > geogCRS
> > 
> > ## Convert to spatial data frame
> > # note that the easting and northing columns are in columns 1 and 2
> > newPlot.Sp.HARV <- st_as_sf(newplot_locations_HARV, coords = c("decimalLon", "decimalLat"), crs = geogCRS)
> > 
> > # view CRS
> > st_crs(newPlot.Sp.HARV)
> > 
> > ## We now have the data imported and in WGS84 Lat/Long. We want to map with plot
> > # locations in UTM so we'll have to reproject.
> > 
> > # remember we have a UTM Zone 18N crs object from previous code
> > utm18nCRS
> > 
> > # reproject the new points into UTM using `utm18nCRS`
> > newPlot.Sp.HARV.UTM <- st_transform(newPlot.Sp.HARV,
> >                                   utm18nCRS)
> > # check new plot CRS
> > st_crs(newPlot.Sp.HARV.UTM)
> > 
> > ## 3
> > # create plot
> > plot(plot_locations_sp_HARV$geometry,
> >      main = "NEON Harvard Forest Field Site \nPlot Locations" )
> > 
> > plot(newPlot.Sp.HARV.UTM$geometry,
> >      add = TRUE,  pch=20, col = "darkgreen")
> > 
> > # oops - looks like we are missing a point on our new plot. let's compare
> > # the spatial extents of both objects!
> > st_bbox(plot_locations_sp_HARV)
> > st_bbox(newPlot.Sp.HARV.UTM)
> > 
> > # when you plot in base plot, if the extent isn't specified, then the data that
> > # is added FIRST will define the extent of the plot
> > 
> > plot(st_convex_hull(st_sfc(st_union(plot_locations_sp_HARV))),
> >      main = "Comparison of Spatial Object Extents\nPlot Locations vs New Plot Locations")
> > 
> > plot(st_convex_hull(st_sfc(st_union(newPlot.Sp.HARV.UTM))),
> >      col = "darkgreen",
> >      add = TRUE)
> > 
> > # looks like the green box showing the newPlot extent extends
> > # beyond the plot.locations extent.
> > 
> > # We need to grab the x min and max and y min from our original plots
> > # but then the ymax from our new plots
> > 
> > originalPlotExtent <- st_bbox(plot_locations_sp_HARV)
> > newPlotExtent <- st_bbox(newPlot.Sp.HARV.UTM)
> > 
> > # set xmin and max
> > xmin <- originalPlotExtent[1]
> > xmax <- originalPlotExtent[3]
> > ymin <- originalPlotExtent[2]
> > ymax <- newPlotExtent[4]
> > 
> > # 3 again... re-plot
> > # try again but this time specify the x and ylims
> > # note: we could also write a function that would harvest the smallest and
> > # largest
> > # x and y values from an extent object. This is beyond the scope of this episode.
> > plot(plot_locations_sp_HARV$geometry,
> >      main = "NEON Harvard Forest Field Site\nVegetation & Phenology Plots",
> >      pch=8,
> >      col = "purple",
> >      xlim = c(xmin, xmax),
> >      ylim = c(ymin, ymax))
> > 
> > plot(newPlot.Sp.HARV.UTM$geometry,
> >      add = TRUE,  pch=20, col = "darkgreen")
> > 
> > # when we create a legend in R, we need to specify the text for each item
> > # listed in the legend.
> > legend("bottomright",
> >        legend = c("Vegetation Plots", "Phenology Plots"),
> >        pch = c(8, 20),
> >        bty = "n",
> >        col = c("purple", "darkgreen"),
> >        cex = 1.3)
> > ```
> {: .solution}
{: .challenge}

## Export a Shapefile

We can write an `R` spatial object to a shapefile using the `st_write` function
in `sf`. To do this we need the following arguments:

* the name of the spatial object (`plot_locations_sp_HARV`)
* the directory where we want to save our shapefile
           (to use `current = getwd()` or you can specify a different path)
* the name of the new shapefile  (`PlotLocations_HARV`)
* the driver which specifies the file format (ESRI Shapefile)

We can now export the spatial object as a shapefile.

``` {r write-shapefile, warnings="hide", eval=FALSE}
st_write(plot_locations_sp_HARV,
         "data/PlotLocations_HARV.shp", driver = "ESRI Shapefile")
```
